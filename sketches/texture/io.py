"""
I/O utilities for texture synthesis.

Provides export functions for height maps, normal maps, and OBJ meshes.
"""

import os
import json
import math
import numpy as np
from typing import Dict, Any, Optional, Tuple

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False


def export_heightmap_png(
    height_field: np.ndarray,
    output_path: str,
    bit_depth: int = 8
) -> str:
    """
    Export height field as grayscale PNG.

    Args:
        height_field: 2D array of heights [0, 1]
        output_path: Output file path
        bit_depth: 8 or 16 bit

    Returns:
        Path to created file
    """
    if not HAS_PIL:
        raise ImportError("PIL/Pillow required for PNG export")

    h = np.array(height_field)
    h = np.clip(h, 0, 1)

    if bit_depth == 16:
        h_int = (h * 65535).astype(np.uint16)
        img = Image.fromarray(h_int, mode='I;16')
    else:
        h_int = (h * 255).astype(np.uint8)
        img = Image.fromarray(h_int, mode='L')

    img.save(output_path)
    return output_path


def export_normalmap_png(
    normal_map: np.ndarray,
    output_path: str
) -> str:
    """
    Export normal map as RGB PNG.

    Args:
        normal_map: 3D array (H, W, 3) with values in [0, 1]
        output_path: Output file path

    Returns:
        Path to created file
    """
    if not HAS_PIL:
        raise ImportError("PIL/Pillow required for PNG export")

    rgb = (normal_map * 255).astype(np.uint8)
    img = Image.fromarray(rgb, mode='RGB')
    img.save(output_path)
    return output_path


def export_obj_with_uv(
    output_path: str,
    u_steps: int = 32,
    v_steps: int = 32,
    egg_factor: float = 0.3,
    texture_file: Optional[str] = None
) -> Tuple[str, Optional[str]]:
    """
    Export egg mesh as OBJ with UV coordinates.

    Args:
        output_path: Path for .obj file
        u_steps: Resolution around equator
        v_steps: Resolution pole-to-pole
        egg_factor: Egg shape factor
        texture_file: Optional texture filename for MTL reference

    Returns:
        (obj_path, mtl_path) - mtl_path is None if no texture specified
    """
    vertices = []
    uvs = []
    normals = []
    faces = []

    # Generate vertices, UVs, normals
    for vi in range(v_steps + 1):
        v = vi / v_steps
        phi = v * math.pi

        egg_mod = 1.0 - egg_factor * math.cos(phi)

        for ui in range(u_steps + 1):
            u = ui / u_steps
            theta = u * 2 * math.pi

            x = math.sin(phi) * math.cos(theta) * egg_mod
            y = math.cos(phi)
            z = math.sin(phi) * math.sin(theta) * egg_mod

            vertices.append((x, y, z))
            uvs.append((u, 1 - v))  # Flip V for OBJ convention

            # Approximate normal
            length = math.sqrt(x*x + y*y + z*z)
            if length > 1e-6:
                normals.append((x/length, y/length, z/length))
            else:
                normals.append((0, 1, 0))

    # Generate faces (quads as triangles)
    for vi in range(v_steps):
        for ui in range(u_steps):
            # Indices (1-based for OBJ)
            i00 = vi * (u_steps + 1) + ui + 1
            i10 = vi * (u_steps + 1) + (ui + 1) + 1
            i01 = (vi + 1) * (u_steps + 1) + ui + 1
            i11 = (vi + 1) * (u_steps + 1) + (ui + 1) + 1

            # Two triangles per quad
            faces.append((i00, i10, i11))
            faces.append((i00, i11, i01))

    # Write OBJ file
    mtl_path = None
    mtl_name = None

    if texture_file:
        mtl_name = os.path.splitext(os.path.basename(output_path))[0]
        mtl_path = os.path.splitext(output_path)[0] + ".mtl"

    with open(output_path, 'w') as f:
        f.write("# Egg mesh generated by texture module\n")

        if mtl_name:
            f.write(f"mtllib {os.path.basename(mtl_path)}\n")

        f.write("\n# Vertices\n")
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")

        f.write("\n# Texture coordinates\n")
        for uv in uvs:
            f.write(f"vt {uv[0]:.6f} {uv[1]:.6f}\n")

        f.write("\n# Normals\n")
        for n in normals:
            f.write(f"vn {n[0]:.6f} {n[1]:.6f} {n[2]:.6f}\n")

        if mtl_name:
            f.write(f"\nusemtl {mtl_name}\n")

        f.write("\n# Faces (vertex/texture/normal)\n")
        for face in faces:
            f.write(f"f {face[0]}/{face[0]}/{face[0]} "
                    f"{face[1]}/{face[1]}/{face[1]} "
                    f"{face[2]}/{face[2]}/{face[2]}\n")

    # Write MTL file if texture specified
    if mtl_path and texture_file:
        with open(mtl_path, 'w') as f:
            f.write(f"# Material for {os.path.basename(output_path)}\n")
            f.write(f"newmtl {mtl_name}\n")
            f.write("Ka 0.2 0.2 0.2\n")  # Ambient
            f.write("Kd 0.8 0.8 0.8\n")  # Diffuse
            f.write("Ks 0.1 0.1 0.1\n")  # Specular
            f.write("Ns 10.0\n")  # Shininess
            f.write(f"map_Kd {texture_file}\n")  # Diffuse texture

    return output_path, mtl_path


def export_all(
    height_field: np.ndarray,
    normal_map: np.ndarray,
    output_dir: str,
    base_name: str = "texture",
    export_obj: bool = False,
    metadata: Optional[Dict[str, Any]] = None
) -> Dict[str, str]:
    """
    Export all texture assets.

    Args:
        height_field: 2D height array [0, 1]
        normal_map: 3D normal array (H, W, 3) [0, 1]
        output_dir: Directory for output files
        base_name: Base filename (without extension)
        export_obj: Whether to export OBJ mesh
        metadata: Optional metadata dict to save as JSON

    Returns:
        Dict mapping asset type to file path
    """
    os.makedirs(output_dir, exist_ok=True)

    results = {}

    # Height map
    height_path = os.path.join(output_dir, f"{base_name}_height.png")
    export_heightmap_png(height_field, height_path)
    results["height_map"] = height_path

    # Normal map
    normal_path = os.path.join(output_dir, f"{base_name}_normal.png")
    export_normalmap_png(normal_map, normal_path)
    results["normal_map"] = normal_path

    # Optional OBJ
    if export_obj:
        obj_path = os.path.join(output_dir, f"{base_name}.obj")
        obj_file, mtl_file = export_obj_with_uv(
            obj_path,
            texture_file=f"{base_name}_height.png"
        )
        results["obj"] = obj_file
        if mtl_file:
            results["mtl"] = mtl_file

    # Optional metadata
    if metadata is not None:
        meta_path = os.path.join(output_dir, f"{base_name}_meta.json")
        # Convert numpy types for JSON serialization
        serializable_meta = {}
        for k, v in metadata.items():
            if isinstance(v, np.ndarray):
                serializable_meta[k] = v.tolist()
            elif isinstance(v, (np.float32, np.float64)):
                serializable_meta[k] = float(v)
            elif isinstance(v, (np.int32, np.int64)):
                serializable_meta[k] = int(v)
            else:
                serializable_meta[k] = v

        with open(meta_path, 'w') as f:
            json.dump(serializable_meta, f, indent=2)
        results["metadata"] = meta_path

    return results


def load_image_as_array(
    path: str,
    normalize: bool = True
) -> np.ndarray:
    """
    Load image file as numpy array.

    Args:
        path: Path to image file
        normalize: If True, normalize to [0, 1]

    Returns:
        2D (grayscale) or 3D (color) numpy array
    """
    if not HAS_PIL:
        raise ImportError("PIL/Pillow required for image loading")

    img = Image.open(path)
    arr = np.array(img)

    # Convert to grayscale if needed
    if arr.ndim == 3 and arr.shape[2] >= 3:
        # Use luminance formula
        arr = 0.299 * arr[:, :, 0] + 0.587 * arr[:, :, 1] + 0.114 * arr[:, :, 2]

    if normalize and arr.max() > 1.0:
        arr = arr.astype(np.float32) / 255.0

    return arr


def load_config(config_path: str) -> Dict[str, Any]:
    """
    Load texture synthesis configuration from JSON.

    Args:
        config_path: Path to JSON config file

    Returns:
        Configuration dict
    """
    with open(config_path, 'r') as f:
        return json.load(f)


def save_config(config: Dict[str, Any], config_path: str) -> str:
    """
    Save texture synthesis configuration to JSON.

    Args:
        config: Configuration dict
        config_path: Output path

    Returns:
        Path to saved file
    """
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=2)
    return config_path
